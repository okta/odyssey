import {
  Canvas,
  Meta,
  Title,
  Subtitle,
  Description,
  Primary,
  Controls,
  Stories,
} from "@storybook/addon-docs";
import { Story } from "@storybook/blocks";
import * as DataTableStories from "./DataTable.stories";

<Meta of={DataTableStories} />

<Title of={DataTableStories} />
<Subtitle of={DataTableStories} />
<Description of={DataTableStories} />
<Primary of={DataTableStories} />
<Controls />

## Architectural philosophy

`DataTable` is a "bring-your-own-logic" component — it provides all the UI you need
to create the table, along with the callbacks that allow you to hook your own logic
into that UI.

Typically, this will mean firing a call to an API whenever the table state changes —
whenever a column is sorted, a row is reordered, more data is loaded, a filter is applied, etc.

This demo provides some simple client-side dummy logic to demonstrate this, but isn't
as robust as a real implementation would be.

## Passing data into the table

Every table needs to have the `columns` prop set. `columns` should be an array of `DataTableColumn` objects, defined as such:

```tsx
type DataTableColumn = {
  accessorKey: string;
  header: string;
  Cell?: MRT_ColumnDef<MRT_RowData>["Cell"];
  filterVariant?: MRT_ColumnDef<MRT_RowData>["filterVariant"];
  filterControl?: (typeof dataFilterVariantValues)[number];
  filterSelectOptions?: Array<{ label: string; value: string }>;
  size?: number;
  minSize?: number;
  maxSize?: number;
  enableColumnFilter?: boolean;
  enableGlobalFilter?: boolean;
  enableSorting?: boolean;
  enableResizing?: boolean;
  enableHiding?: boolean;
};
```

While this includes many options, a typical column only needs an `accessorKey` and a `header`:

```tsx
const column: DataTableColumn = {
  accessorKey: "city",
  header: "City",
};
```

(The `accessorKey` is a unique id for the column, and `header` is the label shown in the column head.)

The table must also include a `getData` function, which takes the data you provide and pipes it into the DataTable.

## Callbacks

Any user action will fire a callback allowing you to provide your own logic. These callbacks are:

`getData`, which is fired whenever the following parameters change:

- page
- resultsPerPage
- search
- filters
- sort

Use `getData` to update the table data whenever the table is searched, paged, filtered, sorted, etc.

`onChangeRowSelection` is fired whenever the user selects one or more rows.

`onReorderRows` is fired whenever rows are reordered (such as via drag-and-drop or the row actions menu). It'll send through the `rowId` (retrieved via `getRowId`) and the `newIndex` as a number.

`getRowId` is an optional function that specifies how the table retrieves the unique ID from each row. By default, the table will generate unique identifiers for each row and use those, but if your data already has unique ids, you can use this function to specify how it can retrieve those.

## Customizing the table

`DataTable` provides numerous props that enable or disable rich functionality. Not every
table will need every feature; some tables won't need user-changeable row density, for instance.

Here are the features you can toggle, and how:

- Allow users to **change row density** — set `hasChangeableDensity` to `true`
- Allow users to **resize columns** — set `hasColumnResizing` to `true`
- Allow users to **show/hide individual columns** — set `hasColumnVisibility` to `true`
- Provide **filtering** — set `hasFilters` to `true`
- Provide **pagination** — set `hasPagination` to `true`
- Allow users to **select rows** — set `hasRowSelection` to `true`
- Provide **search** — set `hasSearch` to `true`
- Allow users to **sort columns** — set `hasSorting` to `true`
- Allow users to **reorder rows** via a drag-and-drop interface — set `hasRowReordering` to `true`

Some additional parameters can be tweaked:

- By default, the search callback fires whenever the user changes the search input. **To search on submit**, set `searchOnSubmit` to `true`.
- Pagination includes a "next" and "previous" button by default. To change to **a "Load more" button**, set `paginationType` to `loadMore`.
- The initial row density is `comfortable`. To **change the initial density** to either `spacious` or `compact`, change the value of `initialDensity`. This will be applied regardless of if `hasChangeableDensity` is true or false.
- To **change the number of results** shown at a time from the default 20, set `resultsPerPage`.
- To add **action buttons** to each row, pass a `Button` or fragment to `rowActionButtons`.
- To add **an action menu with custom items** to each row, pass `MenuItem`s to `rowActionMenuItems`. This can be used independently or in conjunction with `rowActionButtons`.

## An end-to-end example

`DataTable` is a large component with lots of parameters, so to reduce confusion, here's an example of what a full implementation looks like.

In this example, we're creating **a table that displays a list of people**.

We'll start by defining a `Person` type:

```tsx
type Person = {
  order: number;
  id: string;
  name: string;
  city: string;
  state: string;
  age: number;
  risk: "high" | "medium" | "low";
};
```

And now we'll define the columns for the table:

```tsx
const columns: DataTableColumn[] = [
  {
    accessorKey: "order",
    header: "Original order",
    enableColumnFilter: false,
    size: 120,
  },
  {
    accessorKey: "name",
    header: "Name",
    enableHiding: false,
  },
  {
    accessorKey: "city",
    header: "City",
  },
  {
    accessorKey: "state",
    header: "State",
  },
  {
    accessorKey: "age",
    header: "Age",
    size: 80,
    filterVariant: "range",
  },
  {
    accessorKey: "risk",
    header: "Risk level",
    Cell: ({ cell }) => {
      const value = cell.getValue<string>();
      const severity =
        value === "low" ? "success" : value === "medium" ? "warning" : "error";
      return (
        <Status
          label={value.charAt(0).toUpperCase() + value.slice(1)}
          severity={severity}
          variant="pill"
        />
      );
    },
    filterVariant: "multi-select",
    filterSelectOptions: [
      {
        label: "Low",
        value: "low",
      },
      {
        label: "Medium",
        value: "medium",
      },
      {
        label: "High",
        value: "high",
      },
    ],
  },
];
```

Now, let's define a function to retrieve data, assuming that the data is an array of `Person` objects.

```tsx
const fetchData = ({
  initialData,
  page = 1,
  resultsPerPage = 20,
  search,
  filters,
  sort,
}: {
  initialData: Person[];
  page?: number;
  resultsPerPage?: number;
  search?: string;
  filters?: DataFilter[];
  sort?: MRT_SortingState;
}) => {
  let filteredData = [...initialData];

  // Implement text-based query filtering
  if (search) {
    filteredData = filteredData.filter((row) =>
      Object.values(row).some((value) =>
        value.toString().toLowerCase().includes(search.toLowerCase()),
      ),
    );
  }

  // Implement column-specific filtering
  if (filters) {
    filteredData = filteredData.filter((row) => {
      return filters.every(({ id, value }) => {
        // If filter value is null or undefined, skip this filter
        if (value === null || value === undefined) {
          return true;
        }

        // General filtering for all columns
        return row[id as keyof Person]?.toString().includes(value.toString());
      });
    });
  }

  // Implement sorting
  if (sort && sort.length > 0) {
    filteredData.sort((a, b) => {
      for (const { id, desc } of sort) {
        const aValue = a[id as keyof Person];
        const bValue = b[id as keyof Person];

        if (aValue < bValue) return desc ? 1 : -1;
        if (aValue > bValue) return desc ? -1 : 1;
      }

      return 0;
    });
  }

  // Implement pagination
  const startIdx = (page - 1) * resultsPerPage;
  const endIdx = startIdx + resultsPerPage;
  const paginatedData = filteredData.slice(startIdx, endIdx);

  return paginatedData;
};
```

We'll also need a function to handle row selection:

```tsx
const handleRowSelection = (rowSelection) => {
  console.log(rowSelection); // This should do something real
};
```

And, finally, a function to deal with row reordering. Without this, rows won't stick when reordered!

```tsx
const reorderData = ({
  rowId,
  newRowIndex,
}: {
  rowId: string;
  newRowIndex: number;
}) => {
  const updatedData = incomingData;

  const rowIndex = updatedData.findIndex((row) => row.id === rowId);

  if (rowIndex !== -1) {
    // Remove the row from its current position
    const [removedRow] = updatedData.splice(rowIndex, 1);

    // Insert the row at the new index
    updatedData.splice(newRowIndex, 0, removedRow);
  }

  setData(updatedData);
};
```

Now, finally, here's what the component itself looks like:

```tsx
<DataTable
  getData={getData}
  columns={columns}
  onReorderRows={onReorderRows}
  onChangeRowSelection={onChangeRowSelection}
  initialDensity={initialDensity}
  hasChangeableDensity={hasChangeableDensity}
  hasColumnResizing={hasColumnResizing}
  hasColumnVisibility={hasColumnVisibility}
  hasFilters={hasFilters}
  hasPagination={hasPagination}
  hasRowSelection={hasRowSelection}
  hasSearch={hasSearch}
  hasSorting={hasSorting}
  hasRowReordering={hasRowReordering}
  hasSearchSubmitButton={hasSearchSubmitButton}
  searchDelayTime={searchDelayTime}
  currentPage={currentPage}
  resultsPerPage={resultsPerPage}
  totalRows={totalRows}
/>
```

Voila — a working table with sorting, filtering, search, pagination, and reordering.

## Gotchas

It is very, very important that you memoize your callbacks! Performance slows to a crawl if you don't.
For the best performance, keep your `getData` and `onChangeRowSelection` functions outside of the component
and then call them from within, passing the table data in at the same time.

## Upgrade guide

We've made some API changes between the previous version (in Odyssey Labs) and this stable version.

Be aware of the following:

- `fetchDataFn` is now `getData`
- `onRowSelectionChange` is now `onChangeRowSelection`
- `reorderDataFn` is now `onReorderRows`
- Within `reorderDataFn`, the param `newIndex` is now `newRowIndex`
