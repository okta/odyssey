import type { CommandModule } from "yargs";

import { mkdir, readdir, readFile, writeFile } from "node:fs/promises";
import { format, parse, relative, resolve } from "node:path";

import { getLogger } from "../utils";

const CONFIG = {
  TRANSLATION_PATH_SEGMENTS: ["src", "properties", "ts"],
  I18N_OUTPUT_PATH_SEGMENTS: ["src", "i18n.generated"],
  CONTRIBUTION_TOOLING_PATH_SEGMENTS: [
    "src",
    "contribution-tooling",
    "index.js",
  ],
  FILENAMES: {
    RESOURCES: "i18n.resources.ts",
    TYPES: "i18n.types.ts",
    I18N: "i18n.ts",
  },
} as const;

const getIsOdysseyReactMuiPackage = () =>
  process.cwd().includes("packages/core/odyssey-react-mui");

const i18nAutogeneratedFileNotice =
  "/*\n" +
  " *************************************************************************\n" +
  " *  NOTICE: THIS FILE WAS AUTO-GENERATED BY THE `generate:i18n` SCRIPT.  *\n" +
  " *************************************************************************\n" +
  " */";

const currentYear = new Date().getFullYear();
const copyrightLicence = `/*!
 * Copyright (c) ${currentYear}-present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */`;

export type GenerateI18nArgs = {
  defaultLanguageCode: string;
};

export type TranslationData = {
  absoluteImportPath: string;
  fileName: string;
  filePath: string;
  langCode: string;
};

export type DuplicateInfo = {
  files: { name: string; path: string }[];
  langCode: string;
};

const log = getLogger("i18n");

const tsPathToJs = (tsPath: string): string => {
  return format({
    ...parse(tsPath),
    base: undefined, // use the name and new ext
    ext: ".js",
  });
};

const getPackageName = async () => {
  const packageJsonPath = resolve("package.json");
  const packageJson = JSON.parse(await readFile(packageJsonPath, "utf-8")) as {
    name: string;
  };

  const packageName = packageJson.name.trim().split("/").pop();

  if (!packageName) {
    throw new Error(`No package name found in ${packageJsonPath}`);
  }

  return packageName;
};

const getTranslationFiles = async ({
  defaultLanguageCode,
  packageName,
}: {
  defaultLanguageCode: GenerateI18nArgs["defaultLanguageCode"];
  packageName: string;
}) => {
  const translationFilesDirectory = resolve(
    ...CONFIG.TRANSLATION_PATH_SEGMENTS,
  );

  const files = await readdir(translationFilesDirectory);
  const translationFiles = files.filter(
    (file) => file.startsWith(packageName) && file.endsWith(".ts"),
  );

  const translationData = translationFiles
    .map<TranslationData | null>((file) => {
      // Regex to capture the language code.
      // It handles both 'namespace.ts' and 'namespace_fr.ts'
      const langMatch = file.match(
        new RegExp(`${packageName}(?:_([a-zA-Z_]+))?\\.ts$`),
      );

      // If the regex fails to match entirely, it's an unexpected file format.
      if (!langMatch) {
        return null;
      }

      const jsFileName = tsPathToJs(file.replace(/\\/g, "/"));
      const absoluteImportPath = resolve(
        ...CONFIG.TRANSLATION_PATH_SEGMENTS,
        jsFileName,
      );
      const fileName = file;
      const filePath = resolve(translationFilesDirectory, file);
      // Use the captured group for the langCode, or the defaultLanguageCode as a fallback.
      // Note: defaultLanguageCode is defaulted to 'en' in the CLI args.
      const langCode = langMatch[1] || defaultLanguageCode;

      return {
        absoluteImportPath,
        fileName,
        filePath,
        langCode,
      };
    })
    .filter((value): value is TranslationData => value !== null);

  return {
    translationData,
    translationFilesDirectory,
  };
};

const getTranslationFileDuplicates = ({
  translationData,
}: {
  translationData: TranslationData[];
}) => {
  // Group all files by their resulting langCode.
  const groups = new Map<string, TranslationData[]>();
  for (const data of translationData) {
    if (!groups.has(data.langCode)) {
      groups.set(data.langCode, []);
    }
    groups.get(data.langCode)!.push(data);
  }

  // Find which groups have more than one file.
  const duplicates: DuplicateInfo[] = [];
  for (const group of groups.values()) {
    if (group.length > 1) {
      duplicates.push({
        langCode: group[0].langCode,
        files: group.map((data) => ({
          name: data.fileName,
          path: data.filePath,
        })),
      });
    }
  }

  return duplicates;
};

const prepareFileGeneration = ({ filename }: { filename: string }) => {
  log.generationStart(filename);

  return resolve(...CONFIG.I18N_OUTPUT_PATH_SEGMENTS, filename);
};

const writeFileWithHeader = async ({
  filePath,
  fileContent,
}: {
  fileContent: string;
  filePath: string;
}) => {
  const fileHeader = getIsOdysseyReactMuiPackage()
    ? `${copyrightLicence}\n\n${i18nAutogeneratedFileNotice}`
    : i18nAutogeneratedFileNotice;

  const formattedFileContent = `${fileHeader}\n\n${fileContent}\n`;

  await writeFile(filePath, formattedFileContent);

  log.generationSuccess(filePath);
};

/**
 * Generate `i18n.resources.ts`
 */
const generateI18nResourcesFile = async ({
  translationData,
}: {
  translationData: TranslationData[];
}) => {
  const i18nResourcesFilePath = prepareFileGeneration({
    filename: CONFIG.FILENAMES.RESOURCES,
  });
  const i18nOutputDirectoryPath = resolve(...CONFIG.I18N_OUTPUT_PATH_SEGMENTS);

  const imports = translationData
    .toSorted((a, b) =>
      a.absoluteImportPath.localeCompare(b.absoluteImportPath),
    )
    .map(({ absoluteImportPath, langCode }) => {
      const relativeImportPath = relative(
        i18nOutputDirectoryPath,
        absoluteImportPath,
      );
      return `import { translation as ${langCode} } from "${relativeImportPath}";`;
    })
    .join("\n");

  const resourceKeys = translationData
    .toSorted((a, b) => a.langCode.localeCompare(b.langCode))
    .map(({ langCode }) => `  ${langCode},`)
    .join("\n");

  const i18nResourcesFileContent = `${imports}
import { ResourceRecord } from "./${tsPathToJs(CONFIG.FILENAMES.TYPES)}";

export const resources = {\n${resourceKeys}\n} as const satisfies ResourceRecord;`;

  await writeFileWithHeader({
    filePath: i18nResourcesFilePath,
    fileContent: i18nResourcesFileContent,
  });
};

/**
 *  Generate `i18n.types.ts`
 */
const generateI18nTypesFile = async ({
  defaultLanguageCode,
  packageName,
  translationData,
}: {
  defaultLanguageCode: GenerateI18nArgs["defaultLanguageCode"];
  packageName: string;
  translationData: TranslationData[];
}) => {
  const i18nTypesFilePath = prepareFileGeneration({
    filename: CONFIG.FILENAMES.TYPES,
  });

  const supportedLanguages = translationData
    .toSorted((a, b) => a.langCode.localeCompare(b.langCode))
    .map(({ langCode }) => `  | "${langCode}"`)
    .join("\n");

  const defaultTranslationPath = relative(
    resolve(...CONFIG.I18N_OUTPUT_PATH_SEGMENTS),
    resolve(...CONFIG.TRANSLATION_PATH_SEGMENTS, `${packageName}.js`),
  );

  const i18nTypesFileContent = `import { translation as defaultTranslation } from "${defaultTranslationPath}";

export const defaultLanguageCode = "${defaultLanguageCode}" as const;

/**
 * The namespace for the ${packageName} package.
 */
export const namespace = "${packageName}" as const;
export type i18nNamespace = typeof namespace;

/**
 * Defines the shape of all translation keys for the Odyssey namespace.
 * It's derived from the default (${defaultLanguageCode}) translation file,
 * which acts as the source of truth for all available keys.
 */
export type i18nResourceType = typeof defaultTranslation;

/**
 * Supported languages for translations for the ${packageName} package.
 */
export type SupportedLanguages =
${supportedLanguages};

export type ResourceRecord = Record<
  SupportedLanguages,
  Partial<Record<keyof i18nResourceType, string>>
>;`;

  await writeFileWithHeader({
    filePath: i18nTypesFilePath,
    fileContent: i18nTypesFileContent,
  });
};

/**
 * Generate `i18n.ts`
 */
const generateI18nFile = async () => {
  const i18nFilePath = prepareFileGeneration({
    filename: CONFIG.FILENAMES.I18N,
  });

  const i18nFileContent = `import {
  getTranslationServices,
  TypedTFunction,
} from "@okta/odyssey-contribution-tooling";

import { resources } from "./i18n.resources.js";
import {
  defaultLanguageCode,
  i18nResourceType,
  namespace,
} from "./i18n.types.js";

export type * from "@okta/odyssey-contribution-tooling";

export const { i18n, Trans, TranslationProvider, useTranslation } =
  getTranslationServices({
    defaultLanguageCode,
    namespace,
    resources,
  });

export const translate = i18n.t.bind(
  i18n,
) as TypedTFunction<i18nResourceType>;`;

  await writeFileWithHeader({
    filePath: i18nFilePath,
    fileContent: i18nFileContent,
  });
};

const validateTranslationData = ({
  translationData,
  translationFilesDirectory,
}: {
  translationData: TranslationData[];
  translationFilesDirectory: string;
}) => {
  if (translationData.length === 0) {
    throw new Error(
      `No translation files found in ${translationFilesDirectory}`,
    );
  }

  const translationFileDuplicates = getTranslationFileDuplicates({
    translationData,
  });
  if (translationFileDuplicates.length > 0) {
    const duplicationMessage = translationFileDuplicates
      .map(
        ({ langCode, files }) =>
          `\n  - Language Code "${langCode}" was found in multiple files:` +
          files.map((file) => `\n    - ${file.name} (${file.path})`).join(""),
      )
      .join("");

    throw new Error(
      `Duplicate language codes found. This must be resolved before files can be generated.
${duplicationMessage}

This often happens if a file like 'package-name_en.ts' exists and the default language is also 'en'.`,
    );
  }
};

const generateI18nFiles = async ({ defaultLanguageCode }: GenerateI18nArgs) => {
  const packageName = await getPackageName();

  const { translationData, translationFilesDirectory } =
    await getTranslationFiles({ defaultLanguageCode, packageName });

  // Validate the translation data before proceeding
  validateTranslationData({ translationData, translationFilesDirectory });

  log.info(
    `Starting i18n generation for "${packageName}", using "${defaultLanguageCode}" as the default/fallback language code.`,
  );

  // Create the output directory if it doesn't exist
  await mkdir(resolve(...CONFIG.I18N_OUTPUT_PATH_SEGMENTS), {
    recursive: true,
  });

  await Promise.all([
    generateI18nResourcesFile({ translationData }),
    generateI18nTypesFile({
      defaultLanguageCode,
      packageName,
      translationData,
    }),
    generateI18nFile(),
  ]);

  log.info(`Finished i18n generation!`);
};

export const generateI18nCommand: CommandModule<object, GenerateI18nArgs> = {
  builder: (yargs) =>
    yargs.option("defaultLanguageCode", {
      describe: "The language code to use as the default/fallback",
      type: "string",
      default: "en",
    }),
  command: "generate:i18n",
  describe: "Generate i18n resource and type files for the current package",
  handler: generateI18nFiles,
};
